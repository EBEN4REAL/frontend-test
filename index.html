<html>
    <title></title>
    <head>
        <link href="style.css" rel="stylesheet"  />
    </head>
    <body>
        <!-- MAKING USE OF % WIDTH -->
        <div class="progress_wrapper">
            <div class="progress__wrapper__inner">
                <div class="progress"></div>
            </div>
        </div>
    </body>

    <script type="text/javascript">

        // Reverse a string
        // Palindrome (reads same forward and reversed)
        // Reversing an integer
        // SENTENCE CAPITALIZATION
        // ANAGRAM
        // ARRAY CHUNKING
        // FIZZ BUZZ
        // FIBONNACCI
        // MAX CHARS
        // FACTORIAL
        // PYRAMID
        // FIND VOWELS
        // STEPS
        // SPIRAL MATRIX
        // RUNTIME COMPLEXITY

        /***** DATA STRUCTURES ***/
        // QUEUES
        // LINKED-LISTS
        // STACKS

        const quadraticFormular  = (a,b,c) => {
            const ac = (4*a*c)
            const x = (b * b);
            const sqrtPart =  x - ac
            const ans1 = ((-(b) + Math.sqrt(sqrtPart)) / (2*a)).toFixed(2);
            const ans2 = ((-(b) - Math.sqrt(sqrtPart)) / (2*a)).toFixed(2);
            console.log(ans1);
            console.log(ans2);

        }
        quadraticFormular(1, -5, 6)

        

        const fibonacciSequence = val => {
            let fibArr = [0,1];
            for(let i=2; i<val; i++){
                fibArr.push(fibArr[i-1] + fibArr[i-2])
            } 
            return fibArr;
        }
            
        console.log(fibonacciSequence(7))

        const mumbler = str => {
            const arr = []
            for(i=0; i<str.length; i++) {
                arr.push(`${str[i].toUpperCase()}${str[i].toLowerCase().repeat(i)}`)
            }
            return arr.join("-")
        }

        console.log(mumbler("Eben"))

        const largestFive = (str) => {
            let len = str.length;
            let ff = [];
            for(i = 0; i < len; i++){
                ff.push(str.substring(i, i + 5))
            }
            return ff.sort().reverse()[0];
        }

        console.log(largestFive("8949574857475645"))


        const isPalindrome = str => str.split("").reverse().join("") === str
        console.log(isPalindrome("cac"));

        // OR USING EVERY FUNCTION
        const palindrome = str => {
            return str.split('').every((el,i) => {
                console.log(str[str.length -i - 1])
                return el === str[str.length - i -1]
            })
        }

        console.log(palindrome("cac"))

        const  anagram = (s1, s2) => s1.replace(/[^\w]/g, '').toLowerCase().split("").sort().join("") === s2.replace(/[^\w]/g, '').toLowerCase().split("").sort().join("")
        console.log(anagram("anagram", 'nag a rams'))

        // OR Using character maps
        function buildChatMap(str) {
            const charMap = {}
            for(let char of str.replace(/[^\w]/g, '')) {
                charMap[char] = charMap[char] + 1 || 1
            }
            return charMap
        }
        function anagrams (strA, strB) {
            const aCharMap = buildChatMap(strA)
            const bCharMap = buildChatMap(strB)

            if(Object.keys(aCharMap).length  !== Object.keys(bCharMap).length) {
                return false
            }
            for(let char in aCharMap) {
                if(aCharMap[char] !== bCharMap[char]){
                    return false
                }
            }

            return true
        } 
        console.log(anagrams("anagram", 'nagaram'))
        // FIZZBUZZ
        const fizzBuzz =  () => {
            for(let i=1; i<=100; i++) {
                i % 3 == 0 ? console.log("fizz" + i) : i % 5 == 0  ? console.log("buzz" + i) : i % 3 == 0 && i % 5 == 0 ? console.log("fizzBuzz" + i) : null
            }
        }
        // fizzBuzz()
        // Reversed String without the reverse functio9n
        function reverse(str) {
            let reversed = ""
            for (let char of str) {
                reversed = char + reversed
                console.log(reversed)
            }
            return reversed
        }
        // console.log(reverse('Eben'))

        //OR USINMG REDUCE
        function reverseRed(str) {
            return str.split('').reduce((rev, char) => (char + rev), '')
        }
        console.log(reverseRed('Segun'))


        // Integer Reversal
        function reverseInteger(n) {
            const reversedInteger =  n.toString().split('').reverse().join('')
            if(n < 0) {
                return parseInt(reversedInteger) * -1
            }
            return parseInt(reversedInteger)
        }
            
        console.log(reverseInteger(500))



        // Characters and length maps
        const string = "Ebenezer"
        const chars = {}

        for(let char of string){
            !chars[char] ?  chars[char] = 1 : chars[char] += 1
        }
        console.log(chars)

        // Most frequently occuring number in a string
        function maxChar(str) {
            const obj = {}
            str.split('').forEach(el => {
                obj[el] = obj[el] + 1 || 1
            })
            let max = 0
            let maxChar = ''
            for(let char in obj) {
                if(obj[char] > max) {
                    max = obj[char]
                    maxChar = char
                }
            }
            return maxChar;
        }

        console.log(maxChar('Ebenezer'))

        // Array Chunking
        function chunk(array, size) {
            const chunks = []
            array.forEach(el => {
                const last = chunks[chunks.length - 1]
                if(!last || last.length === size) {
                    chunks.push([el])
                }else {
                    last.push(el)
                }
            })
            return chunks
        }

        // console.log(chunk([1,2,3,4,5,6,7,8,9], 2))

        // OR USING SLICE METHOD
        function chunk(array, size) {
            let chunked = []
            let index = 0;

            while(index < array.length) {
                chunked.push(array.slice(index, index + size))
                index += size
            }
            return chunked
        }
        console.log(chunk([1,2,3,4,5,6,7,8,9], 2))


        // SENTENCE CAPITALIZATION
        const capitalize =  str => (str.split(' ').map((el,i) =>  el[0].toUpperCase() + el.slice(1).toLowerCase()).join(' '))
        // OR 
        const capital = str => {
            let strng = str[0].toUpperCase()
            console.log(strng)

            for(let i =1; i<str.length; i++) {
                if(str[i-1] === ' ') {
                    strng += str[i].toUpperCase()
                }else {
                    strng += str[i].toLowerCase()
                }
            }

            return strng
        }

        console.log(capital('i love going, home'))

        function stairCase(n)  {
            for(let row=0; row<n; row++) {
                let stair = ''
                for(let column = 0; column < n; column++) {
                    if(column <= row) {
                        stair += '#'
                    }else {
                        stair += ' '
                    }
                }
                console.log(stair)
            }
        }
        // stairCase(5)

        // OR using Recursion
        function steps(n, row = 0, stair = '') {
            if(n === row) {
                return;
            }
            if(n === stair.length){
                console.log(stair)
                return steps(n, row + 1)
            }
            if(stair.length <= row) {
                stair += '#'
            }else {
                stair += ' ' 
            }
            steps(n, row, stair)
         }

         // steps(6)

        function stepsPyramid(n) {
            let result = ''
            let base = ((2*n) -1)
            for(let i=1; i<=n; i++) {
                let pillars = (2*i) -1;
                let spaces = (base - pillars) / 2
                result += ' '.repeat(spaces) + '#'.repeat(pillars) + ' '.repeat(spaces)  + '\n'
            }
            console.log(result);
        }

         stepsPyramid(4)

         function stepsPyramidRecursion(n, row=1) {
            let pillars = ((2*row) - 1)
            let spaces = (((2*n) - 1) - pillars) / 2
            let result = ''

            if(row === n) {
                return '#'.repeat(pillars)
            }

            result += ' '.repeat(spaces) + '#'.repeat(pillars) + ' '.repeat(spaces) + '\n' +
            stepsPyramidRecursion(n, row + 1)

            return result

         }
         console.log(stepsPyramidRecursion(4))

         // Factorial
         const Factorial = (num) => {
            // with Recursion
            if(num <= 0) {
                return 1
            }else {
                return (num * Factorial(num - 1));
            }
            // without Recursion
            // let res = 1;
            // for(let i=num; i>1; i--){
            //     res = res * i
            // }
            // console.log(res)
         }

         console.log(Factorial(6))

         const vowels = str => {
            let vowelChars  = ['a', 'e', 'i', 'o', 'u'] 
            let vowelCount = 0
            for(let i=0; i<str.length; i++) {
                let index = vowelChars.indexOf(str[i].toLowerCase())
                if(index > -1) {
                    vowelCount += 1
                }
            }
            return vowelCount
         }

         function vowelsRecursive(str, vowelCount=0, i = 0) {
            let vols = ['a', 'e', 'i', 'o', 'u'] 
            let newStr = str.slice(i)
            if(i === (str.length - 1)) {
                if(vols.includes(newStr.toLowerCase())){
                    return vowelCount += 1
                }else {
                    return vowelCount
                }
            }
            if(vols.includes(newStr.toLowerCase()[0])) {
                vowelCount += 1
            }
            return vowelsRecursive(str.toLowerCase(), vowelCount, i + 1)
        }
         console.log(vowelsRecursive('Joshua'))

        function spiralMatrix(n) {
            let counter = 1
            let matrix = []
            let startRow = 0
            let endRow = n - 1
            let startColumn = 0
            let endColumn = n - 1
            for(let i=0; i<n; i++) {
                matrix.push([])
            }

            while(startColumn <= endColumn && startRow <= endRow) {
               
                // TOP ROW
                for(i=startColumn; i<=endColumn; i++){
                    matrix[startRow][i]  = counter
                    counter++
                }
                startRow++

                // RIGHT COLUMN
                for(i=startRow; i<=endRow; i++) {
                    matrix[i][endColumn] = counter
                    counter++
                }
                endColumn--

                // BOTTOM ROW
                 for(let i=endColumn; i>=startColumn; i--){
                    matrix[endRow][i] = counter
                    counter++
                }
                endRow--

                 // LEFT COLUMN
                for(i=endRow; i>=startRow; i--) {
                    matrix[i][startColumn] = counter
                    counter++
                }
                startColumn++

            }
           return matrix
        }
        console.log(spiralMatrix(3))

        function fib(n) {
            let arrInit = [0,1]
            for(let i=2; i<=n; i++) {
                arrInit.push(arrInit[i-2] + arrInit[i-1])
            }
           return arrInit[n]
        }
        
        // QUEUES
       class Queue {
            constructor() {
                this.data = [];
            }

            add(record) {
                this.data.unshift(record);
            }

            remove() {
                return this.data.pop();
            }
            
            peek() {
                return this.data[this.data.length - 1] //Last Element in the Queue
            }

            getQUeue() {
                return this.data
            }
        }

        function  weave(que_1, que_2) {
            const q = new Queue()
            while (que_1.peek() || que_2.peek()) {
                if(que_1.peek()) {
                    q.add(que_1.remove())
                }
                if(que_2.peek()) {
                    q.add(que_2.remove())
                }
            }
            return q
        }
       let queue_1 = new Queue()
       queue_1.add(1)
       queue_1.add(2)

       let queue_2 = new Queue()
       queue_2.add('HI')
       queue_2.add('THERE')

       const q = weave(queue_1,queue_2 )
       //console.log(q)

        // STACKS
       class Stack {
            constructor() {
                this.data = []
            }
            push(record) {
                this.data.push(record)
            }
            pop() {
                return  this.data.pop()
            }
            peek() {
                return this.data[this.data.length - 1]
            }
        }
       


        class StackQueue {
            constructor() {
                this.stackA = new Stack();
                this.stackB = new Stack();
            }

            add(record) {
                this.stackA.push(record)
            }

            remove() {
                while(this.stackA.peek()) {
                    console.log(this.stackA.pop())
                    this.stackB.push(this.stackA.pop())
                }
                const  record = this.stackB.pop()

                while(this.stackB.peek()) {
                    this.stackA.push(this.stackB.pop())
                }
                return record
            }
            
            peek() {
                while(this.stackA.peek()) {
                    this.stackB.push(this.stackA.pop())
                }
                const  record = this.stackB.peek()

                while(this.stackB.peek()) {
                    this.stackA.push(this.stackB.pop())
                }

                return record;
            }

            getStackA() {
                return this.stackA
            }
            getStackB() {
                return this.stackB
            }
        }


        const sq = new StackQueue()
        sq.add('Eben')
        sq.add(3)
        sq.add(4)
        sq.remove()
        console.log(sq.getStackA())
        console.log(sq.getStackB())

        /***** LINKED LISTS ***/
        /***** In computer science, a linked list is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a collection of 
         * 
         ****/ 
        class Node {
            constructor(data, next = null) {
                this.data = data
                this.next = next
            }
        }
        
        class LinkedList {
            constructor() {
                this.head = null
            }
            insertFirst(data) {
                this.head = new Node(data, this.head)
            }
            size() {
                let count = 0
                let node = this.head

                while(node) {
                    count++
                    node = node.next
                }
                return count
            }
            getFirst() {
                return this.head
            }
            getLast() {
                if(!this.head) {
                    return null
                }
                let node = this.head

                while(node) {
                    if(!node.next) return node
                    node = node.next
                }
            }
            clearList() {
                this.head =  null
                return this.head
            }
            removeFirst() {
                this.head = this.head.next
            }
        }
         const nodeOne = new Node(5)
         const list = new LinkedList()
         list.insertFirst(5)
         list.insertFirst(10)
         list.insertFirst(15)
         list.insertFirst(20)
         list.insertFirst('Eben')
         list.insertFirst(30)
         console.log(list)
         console.log(list.removeFirst())


     























     
    </script>
</html>









